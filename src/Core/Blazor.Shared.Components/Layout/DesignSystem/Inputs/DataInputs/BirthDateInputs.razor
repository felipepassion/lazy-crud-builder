@typeparam T

@inherits InputBase<T>

<div class="date">
    @if (!string.IsNullOrEmpty(this.Label))
    {
        <div class="Date_Label">
            <label>@this.Label</label>
        </div>
    }
    <div class="date_inputs">
        <SelectInput Class="@this.BtnClass" Readonly @bind-Value:after=OnValueChanged @bind-Value=DayValue Placeholder="Dia" DataSet="DateInputEnums.GetDays()" />
        <SelectInput Class="@this.BtnClass" ReadOnly @bind-Value:after=OnValueChanged @bind-Value=MonthValue Placeholder="Mês" DataSet="DateInputEnums.GetMonthsList()" />
        <SelectInput Class="@this.BtnClass" ReadOnly @bind-Value:after=OnValueChanged @bind-Value=YearValue Placeholder="Ano" DataSet="DateInputEnums.GetYears()" />
    </div>
</div>

@code {
    [Parameter] public string? Label { get; set; }
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public string BtnClass { get; set; } = string.Empty;

    public string? DayValue { get; set; }
    public string? MonthValue { get; set; }
    public string? YearValue { get; set; }

    bool _valuesAreNull => string.IsNullOrWhiteSpace(DayValue) && string.IsNullOrWhiteSpace(MonthValue) && string.IsNullOrWhiteSpace(YearValue);
    T? _currentValue => (T?)(object?)(_valuesAreNull ? DateTime.MinValue : new DateTime(int.Parse(YearValue), int.Parse(MonthValue), int.Parse(DayValue)));

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            //OnParametersSetAsync();
        }
        return base.OnAfterRenderAsync(firstRender);
    }

    protected override Task OnParametersSetAsync()
    {
        if (Value == null && !_valuesAreNull)
        {
            this.DayValue = null;
            this.MonthValue = null;
            this.YearValue = null;
            this.StateHasChanged();
        }
        else if (Value != null)
        {
            var val = (DateOnly)(object)Value;
            this.DayValue = val.Day.ToString();
            this.MonthValue = val.Month.ToString();
            this.YearValue = val.Year.ToString();
            this.StateHasChanged();
        }
        return base.OnParametersSetAsync();
    }

    async Task OnValueChanged()
    {
        var parsedSuccess = DateOnly.TryParse($"{this.YearValue}-{this.MonthValue}-{this.DayValue}", out var parsedValue);
        if (parsedSuccess)
        {
            this.Value = (T)(object)parsedValue;
            await ValueChanged.InvokeAsync(this.Value);
        }
    }

    protected override bool TryParseValueFromString(string? value, [MaybeNullWhen(false)] out T result, [NotNullWhen(false)] out string validationErrorMessage)
    {
        try
        {
            // Inicializar as saídas
            result = default!;
            validationErrorMessage = null!;

            // Implementar a lógica de conversão aqui
            if (typeof(T) == typeof(DateOnly) || typeof(T) == typeof(DateOnly?))
            {
                // Se T for string, simplesmente atribuímos o valor
                result = (T)(object)value;
                return result is null ? false : true;
            }
            else
            {
                // Lidar com outros tipos conforme necessário
                // Exemplo: DateTime, bool, etc.
                // Implemente as conversões para outros tipos aqui
            }

            // Se nenhum dos tipos correspondentes for encontrado, retornar false
            validationErrorMessage = $"Failed to parse {typeof(T).Name} from '{value}'.";
            return false;
        }
        catch (Exception ex)
        {
            // Se ocorrer uma exceção durante a conversão, capturar e retornar a mensagem de erro
            result = default!;
            validationErrorMessage = ex.Message;
            return false;
        }
    }
}