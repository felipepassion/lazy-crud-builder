@using Lazy.Crud.Core.Application.DTO.Aggregates.CommonAgg.Models
@using Lazy.Crud.Core.Application.DTO.Http.Models.CommonAgg.Commands.Responses
@using System.Linq.Expressions
@using System.Diagnostics.CodeAnalysis

@typeparam K
@typeparam T where T : IEntityDTO, new()

@inherits InputBase<K>

<div class="form @_focusClass">
    <div class="input-area">

        @if (!string.IsNullOrWhiteSpace(this.Label))
        {
            <label>@this.Label</label>
        }

        <span>
            <input @onfocusin="@this.OnFocusIn"
                   @onfocusout="@this.OnFocusOut"
                   @oninput="OnValueSearchChanged"
                   placeholder="@this.Placeholder"
                   value="@this.ValueAsStr"
                   class="@this.Class"
                   @onchange="async () =>
                   {
                     //if(AfterValueChanged==null) @* return;
                     //await AfterValueChanged(this.Value); *@
                   }
"
                   @onselect="@this.ValueSelected"
                   @attributes="this.AdditionalAttributes" />

            <img class="arrow_default @this._arrowClass open"
                 @onmouseover="@this.OnMouseHoverArrowToggler"
                 @onmouseleave="@this.OnMouseLeaveArrowToggler"
                 @onclick=OnArrowClicked
                 src="/imgs/arrow1.svg" />
        </span>

        @if (!string.IsNullOrWhiteSpace(this.Value?.ToString()) && Class != "mealInput")
        {
            <img @onclick=OnClearBtnClicked class="arrow_default @this._arrowClass close" src="/imgs/x-close.svg" />
        }
    </div>
    <div class="list-options @this._optionClass"
         @onmouseover="@this.OnMouseHoverAutoComplete"
         @onmouseleave="@this.OnMouseLeaveAutoComplete">
        <ul>
            @if (_isLoading)
            {
                <li class="option">
                    <Loading />
                </li>
            }
            else
            {
                @foreach (var option in this._options)
                {
                    <li class="option" @onclick="async ()=>await OnOptionClicked(option)">
                        @option.TitleProperty
                    </li>
                }
            }
        </ul>
    </div>
</div>

@code {
    [Parameter] public Func<T?, Task>? AfterValueChanged { get; set; }
    [Parameter] public string? Label { get; set; }
    [Parameter] public IEnumerable<string>? DataSet { get; set; } = new List<string>();
    [Parameter] public string? Placeholder { get; set; }
    [Parameter] public string? Class { get; set; }
    [Parameter] public string? AdditionalQuery { get; set; }
    [Parameter] public string? InitialValue { get; set; }
    [Parameter] public string? ValueAsStr { get; set; }
    [Parameter] public EventCallback<string?> ValueAsStrChanged { get; set; }
    [Parameter] public bool ReadOnly { get; set; }
    [Parameter] public EventCallback ValueSelected { get; set; }
    [Parameter] public Action? OnClearButtonClicked { get; set; }
    [Parameter] public bool ExclusiveTyping { get; set; } = true;
    [Parameter] public required Expression<Func<T, object>> QuerySelector { get; set; }
    [Parameter] public bool PreserveOptionsOnTypying { get; set; } = false;

    [Inject] HttpClient _http { get; set; } = default!;
    HashSet<T> _options { get; set; } = new HashSet<T>();
    HashSet<T> DataSource = new();

    bool _isVisible = false;
    bool _isHoverAutoCompleteWindow;
    bool _isHoverAutoArrowToggler;
    bool _initialized = false;

    bool _isLoading => this.DataSet is null;

    string? _optionClass => _isVisible ? "options_active" : "options_inactive";
    string? _arrowClass => _isVisible ? "arrow_active" : "arrow_inactive";
    string? _focusClass => _isVisible ? "focus-in" : "focus-out";
    string? _oldInput = null;

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (InitialValue != null)
            {
                ValueAsStr = InitialValue;
                await InvokeAsync(StateHasChanged);
            }
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    protected override bool TryParseValueFromString(string value, [MaybeNullWhen(false)] out K result, [NotNullWhen(false)] out string validationErrorMessage)
    {
        if (typeof(K) == typeof(string))
        {
            result = (K)(object)value;
            validationErrorMessage = null!;
            return true;
        }
        result = default!;
        validationErrorMessage = "The provided value is invalid.";
        return false;
    }

    async Task OnOptionClicked(T opt)
    {
        this.Value = (K)(object)opt?.Id;
        this.ValueAsStr = opt.TitleProperty;
        _isVisible = false;
        await ValueChanged.InvokeAsync(this.Value);
        await ValueSelected.InvokeAsync(this.Value);
        await ValueAsStrChanged.InvokeAsync(this.ValueAsStr);
        if (AfterValueChanged != null) await AfterValueChanged(opt);

        this.StateHasChanged();
    }

    void OnMouseHoverAutoComplete()
    {
        _isHoverAutoCompleteWindow = true;
    }

    void OnMouseLeaveAutoComplete()
    {
        _isHoverAutoCompleteWindow = false;
    }

    void OnMouseHoverArrowToggler()
    {
        _isHoverAutoArrowToggler = true;
    }

    void OnMouseLeaveArrowToggler()
    {
        _isHoverAutoArrowToggler = false;
    }

    async Task OnArrowClicked()
    {
        if (_isHoverAutoArrowToggler)
        {
            if (_isVisible)
            {
                _isVisible = false;
                this.StateHasChanged();
            }
            else
            {
                await OnFocusIn();
            }
        }
    }

    private async Task OnFocusIn()
    {
        if (!_isVisible)
        {
            _isVisible = true;
            await this.OnValueSearchChanged(new ChangeEventArgs() { Value = this.ValueAsStr });
            this.StateHasChanged();
        }
    }

    private async Task OnFocusOut()
    {
        if (!_isHoverAutoArrowToggler)
        {
            if (!_isHoverAutoCompleteWindow)
            {
                _isVisible = false;
                this.StateHasChanged();
            }
        }
    }

    async Task OnClearBtnClicked()
    {
        this.Value = default!;
        this.ValueAsStr = string.Empty;
        _isVisible = false;

        if (ValueChanged.HasDelegate)
        {
            await ValueChanged.InvokeAsync(this.Value);
            await ValueAsStrChanged.InvokeAsync(this.ValueAsStr);
        }
        if (ValueSelected.HasDelegate)
        {
            await ValueSelected.InvokeAsync(this.Value);
            await ValueAsStrChanged.InvokeAsync(this.ValueAsStr);
        }

        if (this.OnClearButtonClicked is not null)
            this.OnClearButtonClicked();

        this.StateHasChanged();
    }

    public async Task<List<T>> OnSearchUpdate()
    {
        var queryProperty = QuerySelector.Body as MemberExpression;
        var queryPropertyName = queryProperty?.Member.Name;

        var result = await _http.SearchAsync<T>(query: $"{queryPropertyName}Contains={this.ValueAsStr}&{AdditionalQuery}&OrderBy={queryPropertyName}");

        if (result.Success)
        {
            return result.Data;
        }

        // TODO: log error

        return new List<T>();
    }

    private async Task OnValueSearchChanged(ChangeEventArgs e)
    {
        this.ValueAsStr = e.Value?.ToString() ?? null;
        var isValueDiff = _oldInput != ValueAsStr;
        var isValueNull = string.IsNullOrWhiteSpace(this.ValueAsStr);

        if (isValueDiff || !_initialized)
        {
            _initialized = true;

            await ValueAsStrChanged.InvokeAsync(this.ValueAsStr);

            if (this.OnSearchUpdate != null)
            {
                var foreignKeyName = this.QuerySelector.GetPropertyNameBySelector();

                if (!ExclusiveTyping && _options.Count > 0 && !isValueNull)
                {
                    _options = _options.OrderByDescending(x =>
                            x?.GetType().GetProperty(foreignKeyName)?.GetValue(x)?.ToString()?.Contains(ValueAsStr!, StringComparison.InvariantCultureIgnoreCase) == true)
                            .ToHashSet();
                }
                else
                {
                    _options = (await this.OnSearchUpdate())
                        .Distinct()
                        .ToHashSet();
                }

                this.DataSet = _options.Select(x => x.GetType()
                    .GetProperty(foreignKeyName)?.GetValue(x)?.ToString() ?? string.Empty);
            }

            this.DataSet ??= (new List<string>());

            _oldInput = e.Value?.ToString();

            this.StateHasChanged();
        }
    }

    void RefreshOptions() => this._options = new();

    public async Task RefreshMe() => await OnValueSearchChanged(new ChangeEventArgs { Value = this.Value });
}
